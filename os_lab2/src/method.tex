\section{Метод решения}

\subsection{Общее описание алгоритма}

Массив делится на равные (почти) части по числу потоков. Каждый поток на своей части находит локальные минимум и максимум. После завершения потоков главный поток сводит частичные результаты и получает глобальные min/max.

\begin{enumerate}
    \item Определить число потоков: \texttt{threads = min(max\_threads, len)}.
    \item Рассчитать размер блока: \texttt{chunk = ceil(len / threads)}.
    \item Для каждого потока передать указатель на данные и границы блока.
    \item Поток вычисляет локальные min/max.
    \item Главный поток ждёт \texttt{pthread\_join()} всех потоков и агрегирует min/max.
\end{enumerate}

\subsection{Архитектура программы}

\begin{itemize}
    \item \textbf{main.c}: парсинг аргументов \texttt{<размер\_массива> <макс\_потоков>}, генерация данных, замер времени, вывод результата.
    \item \textbf{find\_min\_max.c/h}: функция \texttt{find\_min\_max()} создаёт потоки \texttt{pthread}, распределяет блоки массива и объединяет частичные результаты.
    \item Используются только стандартные POSIX API: \texttt{pthread\_create}, \texttt{pthread\_join}.
\end{itemize}

\subsection{Синхронизация}

Синхронизация в рабочей версии не требуется: каждый поток пишет только в свой элемент массива частичных результатов. Агрегация выполняется последовательно в главном потоке после \texttt{join}, что исключает гонки.