\section{Выводы}
В результате выполнения лабораторных работ было получено пять файлов трассировки (\texttt{strace1.txt}, \texttt{strace2.log}, \texttt{strace3.txt}, \texttt{program1\_strace.log}, \texttt{program2\_strace.log}), содержащих полные журналы системных вызовов, выполненных каждой из программ. Анализ этих логов подтвердил, что:
\begin{itemize}
    \item программы используют именно те системные вызовы, которые требуются в соответствии с заданием каждой лабораторной работы;
    \item все критически важные операции (создание процессов, работа с сигналами, использование разделяемой памяти, синхронизация, обработка ошибок) реализованы корректно на уровне системных вызовов;
    \item поведение программ соответствует ожидаемому: процессы создаются и завершаются в нужном порядке, межпроцессное взаимодействие осуществляется штатно, ошибки обрабатываются с использованием стандартных механизмов (errno, проверка возвращаемых значений).
\end{itemize}\\
Лабораторная работа 1:\\
Родительский процесс создаёт два канала (pipe2) и один дочерний процесс через clone() с PID 133320. Родитель передаёт данные через write(4, ...) в первый канал, закрывает ненужные концы каналов (close(3), close(6)) и устанавливает неблокирующий режим для обратного канала через fcntl(5, F\_SETFL, O\_NONBLOCK). Дочерний процесс читает данные из канала, выполняет вычисления и завершается. Родитель ожидает завершения дочернего процесса через wait4() и получает сигнал SIGCHLD, подтверждающий корректное завершение с кодом 0. Требование о межпроцессном взаимодействии через каналы выполнено.\\

Лабораторная работа 2:\\
Главный процесс (PID 6308) запускается с аргументами "100" и "4" (количество элементов массива и количество потоков) и создаёт 4 рабочих потока с помощью clone3(..., CLONE\_THREAD, ...) с PID 6309–6312. Каждый поток получает выделенный стек (примерно 8 МБ) через mmap(..., MAP\_STACK). Все потоки совместно участвуют в поиске минимума и максимума в массиве из 100 элементов. Синхронизация завершения осуществляется через futex(..., FUTEX\_WAIT\_BITSET, ...) — аналог pthread\_join. Результат: минимум -97379, максимум 97791, использовано 4 потока, время выполнения 0.0022 с.\\

Лабораторная работа 3:\\
Родительский процесс (PID 18414) создаёт разделяемый объект в оперативной памяти через openat("/dev/shm/shm", O\_CREAT), устанавливает его размер на 1024 байта (ftruncate) и отображает в память с помощью mmap(..., MAP\_SHARED, ...). Затем регистрирует обработчики сигналов SIGUSR1 и SIGCHLD через rt\_sigaction и создаёт дочерний процесс (PID 18449) через clone(). Синхронизация осуществляется через сигналы: дочерний отправляет SIGUSR1 родителю. Взаимодействие реализовано как через memory-mapped файлы, так и через сигналы — в полном соответствии с заданием.\\

Лабораторная работа 4 (статическая линковка):\\
Программа program1 загружается через execve и автоматически подгружает libimpl1.so.1 при старте, так как она указана в зависимостях на этапе линковки. Библиотека отображается в память через mmap ещё до входа в main(). Пользователь может вызывать функции: команда 1 0 3.14159 0.001 → вычисление интеграла (результат 2.000002), команда 2 42 → перевод в двоичную систему (результат 101010). Однако переключение реализаций невозможно — программа жёстко привязана к первой реализации. Это демонстрирует классический подход link-time binding: быстрый, но негибкий.\\

Лабораторная работа 4 (динамическая загрузка):\\
Программа program2 не зависит от конкретных библиотек на этапе компиляции. При запуске она определяет текущий рабочий каталог через getcwd и загружает библиотеку ../impl1/libimpl1.so через openat + mmap (внутренне — dlopen). Вызовы функций перенаправляются через указатели. Пример: 1 0 3.14159 0.001 → вычисление интеграла (результат 2.000002); 2 42 → перевод в двоичную систему (результат 101010). При завершении программы библиотеки выгружаются из памяти через munmap. Это демонстрирует runtime binding: гибкий, поддерживающий загрузку реализаций во время выполнения без перекомпиляции, но с небольшими накладными расходами.\\

Все реализации корректны на уровне системных вызовов. Архитектурные различия между подходами (процессы vs потоки, pipes vs shared memory, link-time vs runtime linking) чётко прослеживаются в strace и соответствуют теоретическим основам операционных систем.

\pagebreak